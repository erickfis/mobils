# Processamento dos dados 

O banco de dados é carregado e preparado para que possamos responder às questões levantadas. 


```{r libraries}

library(scales)
library(stringr)
library(data.table)
library(chron)
library(dplyr)
library(lubridate)
library(ggplot2)
library(rmarkdown)
library(RColorBrewer)
library(gridExtra)
library(grid)

```



## Tratamento inicial dos dados

Antes de fazer qualquer inferência, vamos primeiramente analisar os dados exportados pela plataforma, procurando avaliar sua qualidade e quais são as transformações necessárias para o seu uso.

<!-- tratar inicial.csv com sed+grep para filtrar 2015 e 2016 -->
<!-- Pega a 1a linha (1 a 5), para cabeçalho -->
<!-- $ sed -n "1,5p" inicial.csv > newData.csv -->

<!-- filtra 2015 e 2016 -->
<!-- $ grep -E "^(,2015|,2016)" inicial.csv >> newData.csv -->


```{r load-e-tratamento-csv, cache=TRUE}
# gatilho tem.novidade futuramente vai ser ativado a partir de comparação com o servidor
tem.novidade <- 0

# procurando por db pronto, salvo em rds
arquivos.local <- dir("../data/")
tem.rds <- grep("rds", arquivos.local)

# se tem novidade ou falta o rds, processar do começo:
if(tem.novidade==1|length(tem.rds)==0) {
        arquivos.local <- arquivos.local[grep("mobills", arquivos.local)]

        # dados <- read.csv(paste0("data/", arquivos.local[1]))
        dados <- fread(paste0("../data/", arquivos.local[1]), na.strings = "")


        for (i in 2:length(arquivos.local)) {
                dados <- bind_rows(dados, fread(
                        paste0("../data/", arquivos.local[i]), 
                        na.strings = "")
                        )
        }

        dados <- tbl_df(dados)
        names(dados) <- tolower(names(dados)) # para facilitar o uso das vars

# # filtrando as informações que interessam,
# Além disso, transformar tudo para lowercase, converter formato de datas,
# renomear variáveis, selecionar as que interessam, criar variável mês

        dadosT <- dados %>% rename(tipo = category, valor = amount,
                                   descrição = description) %>%
                mutate(data = parse_date_time(date, "dmY"),
                       descrição = tolower(as.character(descrição)),
                       tipo = factor(tolower(as.character(tipo))),
                       valor = as.numeric(gsub("\\$|,","", valor)),
                       mes = factor(months(data, abbreviate=TRUE),
                                    levels = c("Jan", "Fev", "Mar", "Abr", "Mai",
                                               "Jun", "Jul", "Ago", "Set", "Out",
                                               "Nov", "Dez"), ordered=TRUE),
                       ano = factor(year(data))
                ) %>%
                select(data, ano, mes, tipo, descrição, valor)


# Vamos agrupar os dados por tipo de gasto, ano e mes, e depois calcular o total de gastos em cada categoria

        dadosT <- dadosT %>% group_by(tipo, ano, mes)
        saveRDS(dadosT, "../data/dados-ok.rds")
        rm(dados)
} else{
        dadosT <- readRDS("../data/dados-ok.rds")

}
        
totais <- summarise(dadosT, total=sum(valor))

```


Transformações necessárias:


- as datas estão em formato char, então são convertidas através do lubridate
- criadas as variáveis mês e ano, para agrupar os dados
- valores estão em formato char, com $ e vírgula
- calculadas as somas por categoria para cada mês e ano

## Análise da qualidade dos dados

```{r passo1, cache=TRUE}
# o gráfico
# as cores:
# Neste caso, temos 20 cat, mas somente 9 cores na paleta brewer padrao

colourCount = length(unique(totais$tipo))
getPalette = colorRampPalette(brewer.pal(9, "Set1"))


plt.p1 <- ggplot(totais, aes(x=mes, y=total, group=tipo, colour=tipo))

plt.p1 <- plt.p1 +  geom_line() + geom_point() +
                scale_colour_manual(values = getPalette(colourCount))+
                facet_grid(ano ~., scale = "free") + 
                labs(title="Gastos por tipo de despesa - dados iniciais", y="Total (R$)", x="Mês") + 
                theme(legend.position="none") +
                theme(plot.title = element_text(hjust = 0.5)) 


```

Analisando o primeiro gráfico, vemos que há problemas em março de 2015, tipo pagamentos. 

Vamos olhar este ponto fora do gráfico mais de perto:


```{r}

# vamos ver do q se trata, para talvez remover do gráfico

sub <- with(dadosT, ano==2015 & mes=="Mar" & tipo=="pagamentos" )

kable(dadosT[which(sub),1:6], caption = "categoria pagamentos, em março de 2015")
```

Da tabela acima, podemos observar que consta um lançamento referente a pagamento de cartão de crédito, mas não é assim que o restante dos lançamentos foram feitos: não foram registrados totais. Este, portanto, foi um erro de uso da plataforma. Vamos, portanto, retirar este ponto da análise.



```{r}

# subset de 2 meses quaisquer, para mostrar que todas as compras no cc são registradas como feitas no dia 25

sub <- with(dadosT, mes %in% c("Jun","Jul") & day(dadosT$data) == 25)
dadosub <- dadosT[which(sub),]
kable(head(dadosub[unique(dadosub$tipo),1:6]), caption = "compras no crédito, registradas no dia 25")

kable(tail(dadosub[unique(dadosub$tipo),1:6]), caption = "compras no crédito, registradas no dia 25")

```

Além disso, verifica-se que todas as despesas pagas no cartão de crédito ficaram registradas na data de vencimento do cartão, dia 25. Este é um defeito da plataforma.


Desta forma, não é possível dizer se a despesa foi feita no mês anterior ou no próprio mês. Ela apenas foi paga no mês onde é lançada. 

Uma vez que a fatura deste cartão é fechada no dia 15, todas as compras realizadas a partir do dia 16 são cobradas apenas na próxima fatura. 

No entanto, como isso ocorre para todos os dados da mesma forma, não há impacto impeditivo na análise.

```{r filtra-dados, cache=TRUE}

# retirando ponto do db
sub <- with(dadosT, ano==2015 & mes=="Mar" & tipo=="pagamentos" & valor > 4000)
dadosFil <- dadosT[which(!sub),]
dadosFil <- group_by(dadosFil, tipo, ano, mes)
totais <- summarise(dadosFil, total=sum(valor)) %>%
                mutate(media = mean(total))


rm(dadosT) # house cleanning

```



```{r passo2, cache=TRUE}
plt.p2 <- ggplot(totais, aes(x=mes, y=total, group=tipo, colour=tipo))

plt.p2 <- plt.p2 +  geom_line() + geom_point() +
                scale_colour_manual(values = getPalette(colourCount))+
                facet_grid(ano ~., scale="free") + 
                labs(title="Gastos por tipo de despesa - dados filtrados", 
                     y="Total (R$)", x="Mês") + 
        
                theme(legend.title=element_blank()) +
                theme(legend.position="bottom") +
                guides(fill=guide_legend(nrow=5, byrow=TRUE)) +
                theme(plot.title = element_text(hjust = 0.5)) 


```

Como podemos ver no gráfico 2, não há mais pontos obviamente fora do gráfico, todos os erros de coleta dados foram filtrados. 

O próximo passo é estudar os tipos de despesas que mais se destacam: alimentação, pagamentos e corolla.

```{r grid, fig.height=10, fig.cap="Tratamento dos dados", cache=TRUE}

# fig.width=10, fig.height=10
grid.arrange(plt.p1, plt.p2,  
             nrow=2, ncol=1)
grid.rect(gp=gpar(fill=NA))
```

