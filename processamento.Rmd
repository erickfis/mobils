# Processamento dos dados 

Este código carrega e prepara o banco de dados para que possamos responder às questões levantadas. 


```{r libraries}

library(scales)
library(stringr)
library(data.table)
library(chron)
library(dplyr)
library(lubridate)
library(ggplot2)
library(rmarkdown)
library(RColorBrewer)
library(gridExtra)
library(grid)

```



## Tratamento inicial dos dados

Antes de procurar estabelecer qualquer correlação, vamos primeiramente analisar os dados exportados pela plataforma, procurando avaliar sua qualidade e quais são as transformações necessárias para o seu uso.

<!-- tratar inicial.csv com sed+grep para filtrar 2015 e 2016 -->
<!-- Pega a 1a linha, para cabeçalho -->
<!-- $ sed -n "1,5p" inicial.csv > newData.csv -->

<!-- filtra 2015 e 2016 -->
<!-- $ grep -E "^(,2015|,2016)" inicial.csv >> newData.csv -->


```{r load-e-tratamento-csv, cache=TRUE}
#load-multiplo

lerRds <- 1

if (lerRds==0){
        arquivos <- dir("data/")
        arquivos <- arquivos[grep("mobills", arquivos)]

        dados <- read.csv(paste0("data/", arquivos[1]))


        for (i in 2:length(arquivos)) {
                dados <- bind_rows(dados, read.csv(paste0("data/", arquivos[i])))
        }

        dados <- tbl_df(dados)
        names(dados) <- tolower(names(dados)) # para facilitar o uso das vars

# # filtrando as informações que interessam,
# Além disso, transformar tudo para lowercase, converter formato de datas,
# renomear variáveis, selecionar as que interessam, criar variável mês

        dadosT <- dados %>% rename(tipo = category, valor = amount,
                                   descrição = description) %>%
                mutate(data = parse_date_time(date, "dmY"),
                       descrição = tolower(as.character(descrição)),
                       tipo = factor(tolower(as.character(tipo))),
                       valor = as.numeric(gsub("\\$|,","", valor)),
                       mes = factor(months(data, abbreviate=TRUE),
                                    levels = c("Jan", "Fev", "Mar", "Abr", "Mai",
                                               "Jun", "Jul", "Ago", "Set", "Out", "Nov",
                                               "Dez"), ordered=TRUE),
                       ano = factor(year(data))
                ) %>%
                select(data, ano, mes, tipo, descrição, valor)



# Vamos agrupar os dados por tipo de gasto, ano e mes, e depois calcular o total de gastos em cada categoria

        dadosT <- tbl_df(dadosT) %>% group_by(tipo, ano, mes)
        saveRDS(dadosT, "data/dados-ok.rds")
} else{
        dadosT <- readRDS("data/dados-ok.rds")

}
        
totais <- summarise(dadosT, total=sum(valor))

```


## Análise da qualidade dos dados

```{r plot1}
# o gráfico
# as cores:
# Neste caso, temos 20 cat, mas somente 9 cores na paleta brewer padrao

colourCount = length(unique(totais$tipo))
getPalette = colorRampPalette(brewer.pal(9, "Set1"))


plt <- ggplot(totais, aes(x=mes, y=total, group=tipo, colour=tipo))

(plt +  geom_line() + geom_point() +
                scale_colour_manual(values = getPalette(colourCount))+
                facet_grid(ano ~., scale = "free") + 
                labs(title="Gastos por tipo de despesa", y="Total (R$)", x="Mês") + 
                theme(plot.title = element_text(hjust = 0.5)) 
)

```

Analisando o primeiro gráfico, vemos que há problemas em março de 2015, tipo pagamentos. 

Vamos olhar este ponto fora do gráfico mais de perto:


```{r tabela1}

# vamos ver do q se trata, para talvez remover do gráfico

sub <- with(dadosT, ano==2015 & mes=="Mar" & tipo=="pagamentos" )

kable(dadosT[which(sub),1:6])
```

Da tabela acima, podemos observar que consta um lançamento referente a pagamento de cartão de crédito, mas não é assim que o restante dos lançamentos foram feitos: não foram registrados totais. Este, portanto, foi um erro de uso da plataforma. Vamos, portanto, retirar este ponto da análise.

Além disso, verifica-se que todas as despesas pagas no cartão de crédito ficaram registradas na data de vencimento do cartão, dia 25. 

```{r tabela2}

# vamos ver do q se trata, para talvez remover do gráfico

sub <- with(dadosT, mes %in% c("Jun","Jul") & day(dadosT$data) == 25)
dadosub <- dadosT[which(sub),]
kable(head(dadosub[unique(dadosub$tipo),1:6]))

kable(tail(dadosub[unique(dadosub$tipo),1:6]))

```


Desta forma, não é possível dizer se a despesa foi feita no mês anterior ou no próprio mês. Ela apenas foi paga no mês onde é lançada. Uma vez que a fatura deste cartão é fechada no dia 15, todas as compras realizadas a partir do dia 16 são cobradas apenas na próxima fatura. 

No entanto, como isso ocorre para todos os dados da mesma forma, não há impacto impeditivo na análise.

```{r filtra-dados, cache=TRUE}

sub <- with(dadosT, ano==2015 & mes=="Mar" & tipo=="pagamentos" & valor > 4000)
dadosFil <- dadosT[which(!sub),]
dadosFil <- group_by(dadosFil, tipo, ano, mes)
totais <- summarise(dadosFil, total=sum(valor)) %>%
                mutate(media = mean(total))


rm(dados, dadosT) # house cleanning

```



```{r plot2}
plt <- ggplot(totais, aes(x=mes, y=total, group=tipo, colour=tipo))

(plt +  geom_line() + geom_point() +
                scale_colour_manual(values = getPalette(colourCount))+
                facet_grid(ano ~., scale="free") + 
                labs(title="Gastos por tipo de despesa", y="Total (R$)", x="Mês") + 
                theme(plot.title = element_text(hjust = 0.5)) 
)

```

Como podemos ver no gráfico 2, não há mais pontos obviamente fora do gráfico, todos os erros de coleta dados foram filtrados. 

O próximo passo é estudar os tipos de despesas que mais se destacam: alimentação, pagamentos e corolla.


